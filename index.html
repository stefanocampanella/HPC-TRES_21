<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>HPC-TRES 2021: Earthquake template-matching using modern Python</title>

	<meta name="description" content="Massive earthquake template-matching on GPUs using modern Python">
	<meta name="author" content="Stefano Campanella">

	<link rel="stylesheet" href="reveal.js/dist/reset.css">
	<link rel="stylesheet" href="reveal.js/dist/reveal.css">
	<link rel="stylesheet" href="reveal.js/dist/theme/ogs.css" id="theme">
	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css" id="highlight-theme">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h1 style="color:white">Earthquake template-matching at scale</h1>
				<p><a href="https://bit.ly/3p9WdSw" target="_blank">https://bit.ly/3p9WdSw</a></p>
			</section>
			
			<section>
				<section>
					<h1>Earthquake template-matching at scale using GPUs and modern Python</h1>
					<p>
						<small><strong>Stefano Campanella</strong></small></p>
					<p>
						<small>Alessandro Vuan, Monica Sugan</small>
					</p>
					<div style="margin: 0 auto; width: 60%; display:flex; justify-content:space-between">
						<img class="plain" src="assets/ogs.png" height="100px">
						<img class="plain" src="assets/hpctres.png" height="100px">
					</div>
				</section>
				
				<section>
					<h3>Outline</h3>
					<ol>
						<li>
							<b>Intro &amp; Motivations</b>
							<ol>
								<li>What is template-matching?</li>
								<li>How is TM used in seismology?</li>
							</ol>
						</li>
						<li>
							<b>Methodology &amp; Implementation</b>
							<ol>
								<li>The workflow</li>
								<li>Computational challenges</li>
								<li>Implementation using modern Python</li>
								<li>Deployment and workload orchestration</li>
							</ol>
						</li>
						<li>
							<b>Results</b>
							<ol>
								<li>The augmented catalogue</li>
								<li>Software improvements</li>
							</ol>
						</li>	
					</ol>
				</section>
			</section>

			<section>
				<section>
					<h2 class='r-fit-text'>What is template-matching?</h2>
				</section>

				<section>
					<h3>Template-matching in computer vision</h3>
					<p>
						Template matching is a technique originally developed in digital image processing to find the part of an image that <em>resemble</em> a given template.
					</p>
					<p class=fragment>
						In its simplest version, the idea is to compute a similarity index as the template moves across the image. If some criterion based on the index is met, there is a match.
					</p>
				</section>

				<section data-background-iframe="https://docs.opencv.org/4.x/d4/dc6/tutorial_py_template_matching.html" data-background-interactive>
				</section>
				
				<section>
					<h3>A template-matching algorithm</h3>
					<p>A straightforward choice for measuring similarity is the so-called normalized cross-correlation \(r\) (Pearson correlation index). Consider the case of a <b>1D</b> image \(x_n\) and of a search for a <b>single occurrence</b> of template \(y_n\):</p>
					<div class="r-frame fragment", data-fragment-index="1", style="display: flex; justify-content: center;">
						<div style="width: 80%; text-align: left; font-family: var(--r-code-font);">
							<p class=fragment data-fragment-index="1"> 
								Inputs ← \( (x_n)_{0 \leq n < M}, (y_n)_{0 \leq n < N} \) where \( M > N\).
							</p>
							<p class=fragment>
								For \(k = 0, \ldots, M - N\) compute \(r_k\), where 
								\[ 
									r_k = \frac{\sum\limits^N_{n = 0} ( x_n - \langle x \rangle ) ( y^{(k)}_n - \langle y^{(k)}\rangle )}{\left( \sum\limits^N_{n = 0} ( x_n - \langle x \rangle )^2 \sum\limits^N_{n = 0} ( y^{(k)}_n - \langle y^{(k)} \rangle )^2 \right)^\frac{1}{2}} \; .
								\]
							</p>
							<p class=fragment>
								Output ← detection at \(\text{argmax} \left( r_k \right)\).
							</p>
						</div>
					</div>
				</section>
			</section>

			<section>
				<section>
					<h2 class='r-fit-text'>Template-matching in seismology</h2>
				</section>

				<section>
					<h3>Earthquake template-matching</h3>
					<p>
						The previous one dimensional case is the one of seismology, with one important difference: both the signal and the template comprise <b>several time series</b> (traces). Simplifying a bit, <b>each trace is a seismogram registered at a particular location</b>.
					</p>
					<p class=fragment>
						Here the <b>template</b> is the relevant part of the signal produced by a <b>known earthquake</b> (i.e. coming from an existing catalogue) at that location. The similarity index is usually the mean value of the ones of each trace. If there is a match, one might reasonably conclude that it has approximately the <b>same source</b> as the template.
					</p>
					<p class=fragment>
						Indeed, the <b>relative displacement of traces</b> in the template (delays) encodes important information about the <b>position of the source</b> and the value of the similarity index encompasses both the similarity of waveforms and delays.
					</p>
				</section>

				<section>
					<h3>Example of earthquake TM setting</h3>
					<img class="plain" src="assets/eqtm_data.jpg">
					<p><em>from Kato et al., (2013, GRL)</em></p>
				</section>
				
				<section>
					<h3>Example of detection</h3>
					<div style="margin: 0 auto; width: 100%; display:flex; justify-content:space-between">
						<div style="width: 60%">
							<img class="plain" src="assets/eqtm_match.png" height=70%>
							<p><em>from Kato et al., (2013, GRL)</em></p>
						</div>
						<div class=fragment style="width: 40%;">
							<h4>Subtleties</h4>
							<ul>
								<li class=fragment>Procedure depends on data preparation (trim, resample, filter, etc.)</li>
								<li class=fragment>Noise level is not known nor constant</li>
								<li class=fragment>Seismic network might change</li>
								<li class=fragment>Traces not perfectly synchronized</li>
								<li class=fragment>Template and detection don't have the exact same location</li>
								<li class=fragment>\(r_k\) can change significanlty over few samples</li>
								<li class=fragment>Filter out spurious detections</li>
							</ul>
						</div>
					</div>
				</section>
				
				<section>
					<h3>Scientific goal</h3>
					<p>
						This technique has been applied to the study (RISE, Horizon 2020) of the central Italy normal fault, in particular to the pre-sequence of the Amatrice earthquake (August 24th, 2016).

						
					</p>
					<p>
						The relevance of such studies concernes:
						<ol>
							<li>Production of so-called augmented catalogues for statistical purposes.</li>
							<li>Analysis of seismogenic processes.</li>
						</ol>
					</p>
				</section>
			</section>
			
			<section>
				<section>
					<h2 class="r-fit-text">The workflow</h2>
				</section>

				<section>
					<h3>The whole analysis in plain language</h3>
					<p>Find all the matches in the data for each template and store the result on disk.</p>
				</section>

				<section>
					<h3>The workload for the analysis of the Amatrice pre-sequence</h3>
					<ul>
						<li>48,000 templates, 5 seconds each</li>
						<li>3,600 days of continuous data recorded at 20Hz</li>
						<li>Up to 18 traces used for TM</li>
						<li>Previous TM performance ≈ 0.05 second / trace template day</li>
					</ul>
					<p>
						Previous version of the software was infeasible for analyses of this size and would have required order of 200,000,000 core hours.
					</p>
				</section>
			</section>
			
			<section>
				<section>
					<h2 class="r-fit-text">Optimizations</h2>
				</section>

				<section>
					<h3>First optimizations</h3>
					<p>
						The problem is <b>embarassingly parallel and CPU-bounded</b>. The computation for one pair (template, day) is independent from the others and the largest fraction of time is spent in the <b>calculation of the cross-correlation</b>, which is \(\mathcal{O}(n^2)\). Thus first round of optimizations concerned serial code.
					</p>
					<p>
						Avoiding useless IO accounted for most of the optimizations of this first step. Also error handling had a role (if a bug makes the code fail after 0.01 second one time in ten, you have wasted 4,000,000 core hours).
					</p>
					<p>
						However, analizing each pair separately would scale the IO as well. Workload orchestration needs to take that into account. 
					</p>
				</section>

				<section>
					<h3>Why is Python used in scientific computing?</h3>
				</section>

				<section>
					<h3>Computing the normalized cross-correlation using array programming</h3>
				</section>
				
				<section>
					<h3>Parallel computing in Python</h3>
				</section>

				<section>
					<h3>Workload orchestration</h3>
						<p>One process per day, processing all templates using a thread pool.</p>
						<p>Why use Marconi if you have Marconi 100?</p>
						<p>ISCRA C</p>
				</section>

				<section>
					<h3>GPU/CPU agnostic code</h3>
				</section>

				<section>
					<h3>Using the right serialization format</h3>
				</section>
			</section>

			<section>
				<section>
					<h2 class="r-fit-text">Results</h2>
				</section>

				<section>
					<h3>All the analysis took a couple of days (the machine was busy)</h3>
				</section>

				<section>
					<h3>Scientific validation: check</h3>
				</section>
			</section>
		</div>
	</div>

	<script src="reveal.js/dist/reveal.js"></script>
	<script src="reveal.js/plugin/notes/notes.js"></script>
	<script src="reveal.js/plugin/markdown/markdown.js"></script>
	<script src="reveal.js/plugin/highlight/highlight.js"></script>
	<script src="reveal.js/plugin/math/math.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
		});
	</script>
</body>

</html>
